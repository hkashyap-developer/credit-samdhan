"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-simple-animate";
exports.ids = ["vendor-chunks/react-simple-animate"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-simple-animate/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-simple-animate/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nconst DEFAULT_DURATION = 0.3;\r\nconst DEFAULT_EASE_TYPE = 'linear';\r\nconst DEFAULT_DIRECTION = 'normal';\r\nconst DEFAULT_FILLMODE = 'none';\r\nconst RUNNING = 'running';\r\nconst PAUSED = 'paused';\r\nconst ALL = 'all';\n\nvar calculateTotalDuration = ({ duration = DEFAULT_DURATION, delay = 0, overlay = 0, }) => duration + delay - overlay || 0;\n\nvar isUndefined = (val) => val === undefined;\n\nfunction getSequenceId(sequenceIndex, sequenceId, defaultValue) {\r\n    if (isUndefined(sequenceId) && isUndefined(sequenceIndex)) {\r\n        return defaultValue || 0;\r\n    }\r\n    if (sequenceIndex && sequenceIndex >= 0) {\r\n        return sequenceIndex;\r\n    }\r\n    if (sequenceId) {\r\n        return sequenceId;\r\n    }\r\n    return 0;\r\n}\n\nconst AnimateContext = React__namespace.createContext({\r\n    animationStates: {},\r\n    register: () => { },\r\n});\r\nfunction AnimateGroup({ play, sequences = [], children, }) {\r\n    const [animationStates, setAnimationStates] = React__namespace.useState({});\r\n    const animationsRef = React__namespace.useRef({});\r\n    const register = React__namespace.useCallback((data) => {\r\n        const { sequenceIndex, sequenceId } = data;\r\n        if (!isUndefined(sequenceId) || !isUndefined(sequenceIndex)) {\r\n            animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data;\r\n        }\r\n    }, []);\r\n    React__namespace.useEffect(() => {\r\n        const sequencesToAnimate = Array.isArray(sequences) && sequences.length\r\n            ? sequences\r\n            : Object.values(animationsRef.current);\r\n        const localAnimationState = {};\r\n        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, { sequenceId, sequenceIndex, duration = DEFAULT_DURATION, delay, overlay, }, currentIndex) => {\r\n            const id = getSequenceId(sequenceIndex, sequenceId, currentIndex);\r\n            const currentTotalDuration = calculateTotalDuration({\r\n                duration,\r\n                delay,\r\n                overlay,\r\n            });\r\n            const totalDuration = currentTotalDuration + previous;\r\n            localAnimationState[id] = {\r\n                play,\r\n                pause: !play,\r\n                delay: (delay || 0) + previous,\r\n                controlled: true,\r\n            };\r\n            return totalDuration;\r\n        }, 0);\r\n        setAnimationStates(localAnimationState);\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [play]);\r\n    return (React__namespace.createElement(AnimateContext.Provider, { value: { animationStates, register } }, children));\r\n}\n\nvar secToMs = (ms) => (ms || 0) * 1000;\n\nfunction Animate(props) {\r\n    const { play, children, render, start, end, complete = '', onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, sequenceId, sequenceIndex, } = props;\r\n    const onCompleteTimeRef = React__namespace.useRef();\r\n    const [style, setStyle] = React__namespace.useState(start || {});\r\n    const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);\r\n    const id = getSequenceId(sequenceIndex, sequenceId);\r\n    React__namespace.useEffect(() => {\r\n        if ((!isUndefined(sequenceIndex) && sequenceIndex >= 0) || sequenceId) {\r\n            register(props);\r\n        }\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    React__namespace.useEffect(() => {\r\n        const animationState = animationStates[id] || {};\r\n        setStyle({\r\n            ...(play || animationState.play ? end : start),\r\n            transition: `${ALL} ${duration}s ${easeType} ${animationState.delay || delay}s`,\r\n        });\r\n        if (play && (complete || onComplete)) {\r\n            onCompleteTimeRef.current = setTimeout(() => {\r\n                complete && setStyle(complete);\r\n                onComplete && onComplete();\r\n            }, secToMs((animationState.delay || delay) + duration));\r\n        }\r\n        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);\r\n    }, [\r\n        id,\r\n        animationStates,\r\n        play,\r\n        duration,\r\n        easeType,\r\n        delay,\r\n        onComplete,\r\n        start,\r\n        end,\r\n        complete,\r\n    ]);\r\n    return render ? render({ style }) : React__namespace.createElement(\"div\", { style: style }, children);\r\n}\n\nvar camelCaseToDash = (camelCase) => camelCase ? camelCase.replace(/[A-Z]/g, c => `-${c.toLowerCase()}`) : '';\n\nconst generateKeyframes = (keyframes) => {\r\n    const animationLength = keyframes.length;\r\n    return keyframes.reduce((previous, keyframe, currentIndex) => {\r\n        const keyframePercentage = parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex;\r\n        if (typeof keyframe === 'string') {\r\n            return `${previous} ${keyframePercentage}% {${keyframe}}`;\r\n        }\r\n        const keys = Object.keys(keyframe);\r\n        if (keys.length && isNaN(+keys[0])) {\r\n            const keyframeContent = keys.reduce((acc, key) => `${acc} ${camelCaseToDash(key)}: ${keyframe[key]};`, '');\r\n            return `${previous} ${keyframePercentage}% {${keyframeContent}}`;\r\n        }\r\n        return `${previous} ${keys[0]}% {${keyframe[keys[0]]}}`;\r\n    }, '');\r\n};\r\nfunction createStyle({ keyframes, animationName, }) {\r\n    return `@keyframes ${animationName} {${generateKeyframes(keyframes)}}`;\r\n}\n\nfunction createTag({ keyframes, animationName, }) {\r\n    var _a, _b, _c, _d;\r\n    let styleTag = document.querySelector('style[data-id=rsi]');\r\n    if (!styleTag) {\r\n        styleTag = document.createElement('style');\r\n        styleTag.setAttribute('data-id', 'rsi');\r\n        document.head.appendChild(styleTag);\r\n    }\r\n    const index = (_c = (_b = (_a = styleTag.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\r\n    try {\r\n        (_d = styleTag.sheet) === null || _d === void 0 ? void 0 : _d.insertRule(createStyle({\r\n            keyframes,\r\n            animationName,\r\n        }), index);\r\n    }\r\n    catch (e) {\r\n        console.error('react simple animate, error found during insert style ', e); // eslint-disable-line no-console\r\n    }\r\n    return {\r\n        styleTag,\r\n        index,\r\n    };\r\n}\n\nvar deleteRules = (sheet, deleteName) => {\r\n    if (!sheet) {\r\n        return;\r\n    }\r\n    const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);\r\n    if (index >= 0) {\r\n        sheet.deleteRule(index);\r\n    }\r\n};\n\nvar createRandomName = () => `RSI-${Math.random()\r\n    .toString(36)\r\n    .substr(2, 9)}`;\n\nvar getPlayState = (pause) => (pause ? PAUSED : RUNNING);\n\nfunction AnimateKeyframes(props) {\r\n    const { children, play = false, pause = false, render, duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, sequenceIndex, keyframes, sequenceId, } = props;\r\n    let pauseValue;\r\n    const animationNameRef = React__namespace.useRef({\r\n        forward: '',\r\n        reverse: '',\r\n    });\r\n    const controlled = React__namespace.useRef(false);\r\n    const styleTagRef = React__namespace.useRef({\r\n        forward: null,\r\n        reverse: null,\r\n    });\r\n    const id = getSequenceId(sequenceIndex, sequenceId);\r\n    const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);\r\n    const animateState = animationStates[id] || {};\r\n    const [, forceUpdate] = React__namespace.useState(false);\r\n    React__namespace.useEffect(() => {\r\n        const styleTag = styleTagRef.current;\r\n        const animationName = animationNameRef.current;\r\n        animationNameRef.current.forward = createRandomName();\r\n        let result = createTag({\r\n            animationName: animationNameRef.current.forward,\r\n            keyframes,\r\n        });\r\n        styleTagRef.current.forward = result.styleTag;\r\n        animationNameRef.current.reverse = createRandomName();\r\n        result = createTag({\r\n            animationName: animationNameRef.current.reverse,\r\n            keyframes: keyframes.reverse(),\r\n        });\r\n        styleTagRef.current.reverse = result.styleTag;\r\n        register(props);\r\n        if (play) {\r\n            forceUpdate(true);\r\n        }\r\n        return () => {\r\n            var _a, _b;\r\n            deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);\r\n            deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    if (animateState.controlled && !controlled.current) {\r\n        pauseValue = animateState.pause;\r\n        if (!animateState.pause) {\r\n            controlled.current = true;\r\n        }\r\n    }\r\n    else {\r\n        pauseValue = pause;\r\n    }\r\n    const style = {\r\n        animation: `${duration}s ${easeType} ${animateState.delay || delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(pauseValue)} ${((animateState.controlled ? animateState.play : play)\r\n            ? animationNameRef.current.forward\r\n            : animationNameRef.current.reverse) || ''}`,\r\n    };\r\n    return render ? render({ style }) : React__namespace.createElement(\"div\", { style: style || {} }, children);\r\n}\n\nfunction useAnimate(props) {\r\n    const { start, end, complete, onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, } = props;\r\n    const transition = React__namespace.useMemo(() => `${ALL} ${duration}s ${easeType} ${delay}s`, [duration, easeType, delay]);\r\n    const [animate, setAnimate] = React__namespace.useState({\r\n        isPlaying: false,\r\n        style: { ...start, transition },\r\n    });\r\n    const { isPlaying, style } = animate;\r\n    const onCompleteTimeRef = React__namespace.useRef();\r\n    React__namespace.useEffect(() => {\r\n        if ((onComplete || complete) && isPlaying) {\r\n            onCompleteTimeRef.current = setTimeout(() => {\r\n                if (onComplete) {\r\n                    onComplete();\r\n                }\r\n                if (complete) {\r\n                    setAnimate((animate) => ({\r\n                        ...animate,\r\n                        style: complete,\r\n                    }));\r\n                }\r\n            }, secToMs(delay + duration));\r\n        }\r\n        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);\r\n    }, [animate, complete, delay, duration, isPlaying, onComplete]);\r\n    return {\r\n        isPlaying,\r\n        style,\r\n        play: React__namespace.useCallback((isPlaying) => {\r\n            setAnimate((animate) => ({\r\n                ...animate,\r\n                style: {\r\n                    ...(isPlaying ? end : start),\r\n                    transition,\r\n                },\r\n                isPlaying,\r\n            }));\r\n        }, [end, start, transition]),\r\n    };\r\n}\n\nfunction useAnimateKeyframes(props) {\r\n    const { duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, keyframes, } = props;\r\n    const animationNameRef = React__namespace.useRef({\r\n        forward: '',\r\n        reverse: '',\r\n    });\r\n    const styleTagRef = React__namespace.useRef({\r\n        forward: null,\r\n        reverse: null,\r\n    });\r\n    const { register } = React__namespace.useContext(AnimateContext);\r\n    const [isPlaying, setIsPlaying] = React__namespace.useState(null);\r\n    const [isPaused, setIsPaused] = React__namespace.useState(false);\r\n    React__namespace.useEffect(() => {\r\n        const styleTag = styleTagRef.current;\r\n        const animationName = animationNameRef.current;\r\n        animationNameRef.current.forward = createRandomName();\r\n        let result = createTag({\r\n            animationName: animationNameRef.current.forward,\r\n            keyframes,\r\n        });\r\n        styleTagRef.current.forward = result.styleTag;\r\n        animationNameRef.current.reverse = createRandomName();\r\n        result = createTag({\r\n            animationName: animationNameRef.current.reverse,\r\n            keyframes: keyframes.reverse(),\r\n        });\r\n        styleTagRef.current.reverse = result.styleTag;\r\n        register(props);\r\n        return () => {\r\n            var _a, _b;\r\n            deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);\r\n            deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    const style = {\r\n        animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(isPaused)} ${isPlaying === null\r\n            ? ''\r\n            : isPlaying\r\n                ? animationNameRef.current.forward\r\n                : animationNameRef.current.reverse}`,\r\n    };\r\n    return {\r\n        style,\r\n        play: setIsPlaying,\r\n        pause: setIsPaused,\r\n        isPlaying: !!isPlaying,\r\n    };\r\n}\n\nfunction createArrayWithNumbers(length) {\r\n    return Array.from({ length }, () => null);\r\n}\n\nfunction useAnimateGroup(props) {\r\n    const { sequences = [] } = props;\r\n    const defaultArray = createArrayWithNumbers(sequences.length).map((_, index) => props.sequences[index].start);\r\n    const [styles, setStyles] = React__namespace.useState(defaultArray);\r\n    const [isPlaying, setPlaying] = React__namespace.useState(false);\r\n    const animationNamesRef = React__namespace.useRef([]);\r\n    const styleTagRef = React__namespace.useRef([]);\r\n    React__namespace.useEffect(() => {\r\n        sequences.forEach(({ keyframes }, i) => {\r\n            if (!Array.isArray(keyframes)) {\r\n                return;\r\n            }\r\n            if (!animationNamesRef.current[i]) {\r\n                animationNamesRef.current[i] = {};\r\n                styleTagRef.current[i] = {};\r\n            }\r\n            animationNamesRef.current[i].forward = createRandomName();\r\n            let result = createTag({\r\n                animationName: animationNamesRef.current[i].forward,\r\n                keyframes,\r\n            });\r\n            styleTagRef.current[i].forward = result.styleTag;\r\n            animationNamesRef.current[i].reverse = createRandomName();\r\n            result = createTag({\r\n                animationName: animationNamesRef.current[i].reverse,\r\n                keyframes: keyframes.reverse(),\r\n            });\r\n            styleTagRef.current[i].reverse = result.styleTag;\r\n        });\r\n        const styleTags = styleTagRef.current;\r\n        const animationNames = animationNamesRef.current;\r\n        return () => Object.values(animationNames).forEach(({ forward, reverse }, i) => {\r\n            var _a, _b;\r\n            deleteRules((_a = styleTags[i].forward) === null || _a === void 0 ? void 0 : _a.sheet, forward);\r\n            deleteRules((_b = styleTags[i].reverse) === null || _b === void 0 ? void 0 : _b.sheet, reverse);\r\n        });\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    const play = React__namespace.useCallback((isPlay) => {\r\n        let totalDuration = 0;\r\n        const animationRefWithOrder = isPlay\r\n            ? animationNamesRef.current\r\n            : [...animationNamesRef.current].reverse();\r\n        const styles = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {\r\n            const { duration = DEFAULT_DURATION, delay = 0, overlay, keyframes, iterationCount = 1, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, end = {}, start = {}, } = current;\r\n            const delayDuration = currentIndex === 0 ? delay : totalDuration;\r\n            const transition = `${ALL} ${duration}s ${easeType} ${delayDuration}s`;\r\n            totalDuration =\r\n                calculateTotalDuration({ duration, delay, overlay }) + totalDuration;\r\n            return keyframes\r\n                ? {\r\n                    animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} ${RUNNING} ${isPlay\r\n                        ? animationRefWithOrder[currentIndex].forward\r\n                        : animationRefWithOrder[currentIndex].reverse}`,\r\n                }\r\n                : {\r\n                    ...(isPlay ? end : start),\r\n                    transition,\r\n                };\r\n        });\r\n        setStyles(isPlay ? styles : [...styles].reverse());\r\n        setPlaying(isPlay);\r\n    }, []);\r\n    return { styles, play, isPlaying };\r\n}\n\nexports.Animate = Animate;\nexports.AnimateGroup = AnimateGroup;\nexports.AnimateKeyframes = AnimateKeyframes;\nexports.useAnimate = useAnimate;\nexports.useAnimateGroup = useAnimateGroup;\nexports.useAnimateKeyframes = useAnimateKeyframes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWFuaW1hdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msc0RBQXNEOztBQUV0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLENBQUM7QUFDRCx3QkFBd0IsaUNBQWlDO0FBQ3pELDhFQUE4RTtBQUM5RSxvREFBb0Q7QUFDcEQ7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RTtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxzRUFBc0UsU0FBUyw2QkFBNkI7QUFDNUc7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLGtLQUFrSztBQUM5SztBQUNBLG1FQUFtRTtBQUNuRSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxFQUFFLFNBQVMsSUFBSSxVQUFVLEVBQUUsOEJBQThCO0FBQ3pGLFNBQVM7QUFDVDtBQUNB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SDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDOztBQUVBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0xBQWtMLFlBQVksSUFBSTtBQUN0TjtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsU0FBUyxJQUFJLFVBQVUsRUFBRSxjQUFjO0FBQ2hGO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVMsSUFBSSxVQUFVLEVBQUUsY0FBYyxJQUFJLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFO0FBQ25JO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7O0FBRUEsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QiwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZW1vLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWFuaW1hdGUvZGlzdC9pbmRleC5qcz81MDgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbltcImRlZmF1bHRcIl0gPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xuXG5jb25zdCBERUZBVUxUX0RVUkFUSU9OID0gMC4zO1xyXG5jb25zdCBERUZBVUxUX0VBU0VfVFlQRSA9ICdsaW5lYXInO1xyXG5jb25zdCBERUZBVUxUX0RJUkVDVElPTiA9ICdub3JtYWwnO1xyXG5jb25zdCBERUZBVUxUX0ZJTExNT0RFID0gJ25vbmUnO1xyXG5jb25zdCBSVU5OSU5HID0gJ3J1bm5pbmcnO1xyXG5jb25zdCBQQVVTRUQgPSAncGF1c2VkJztcclxuY29uc3QgQUxMID0gJ2FsbCc7XG5cbnZhciBjYWxjdWxhdGVUb3RhbER1cmF0aW9uID0gKHsgZHVyYXRpb24gPSBERUZBVUxUX0RVUkFUSU9OLCBkZWxheSA9IDAsIG92ZXJsYXkgPSAwLCB9KSA9PiBkdXJhdGlvbiArIGRlbGF5IC0gb3ZlcmxheSB8fCAwO1xuXG52YXIgaXNVbmRlZmluZWQgPSAodmFsKSA9PiB2YWwgPT09IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZ2V0U2VxdWVuY2VJZChzZXF1ZW5jZUluZGV4LCBzZXF1ZW5jZUlkLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGlmIChpc1VuZGVmaW5lZChzZXF1ZW5jZUlkKSAmJiBpc1VuZGVmaW5lZChzZXF1ZW5jZUluZGV4KSkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgMDtcclxuICAgIH1cclxuICAgIGlmIChzZXF1ZW5jZUluZGV4ICYmIHNlcXVlbmNlSW5kZXggPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBzZXF1ZW5jZUluZGV4O1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcXVlbmNlSWQpIHtcclxuICAgICAgICByZXR1cm4gc2VxdWVuY2VJZDtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XG5cbmNvbnN0IEFuaW1hdGVDb250ZXh0ID0gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KHtcclxuICAgIGFuaW1hdGlvblN0YXRlczoge30sXHJcbiAgICByZWdpc3RlcjogKCkgPT4geyB9LFxyXG59KTtcclxuZnVuY3Rpb24gQW5pbWF0ZUdyb3VwKHsgcGxheSwgc2VxdWVuY2VzID0gW10sIGNoaWxkcmVuLCB9KSB7XHJcbiAgICBjb25zdCBbYW5pbWF0aW9uU3RhdGVzLCBzZXRBbmltYXRpb25TdGF0ZXNdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7fSk7XHJcbiAgICBjb25zdCBhbmltYXRpb25zUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe30pO1xyXG4gICAgY29uc3QgcmVnaXN0ZXIgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKChkYXRhKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzZXF1ZW5jZUluZGV4LCBzZXF1ZW5jZUlkIH0gPSBkYXRhO1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoc2VxdWVuY2VJZCkgfHwgIWlzVW5kZWZpbmVkKHNlcXVlbmNlSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnNSZWYuY3VycmVudFtnZXRTZXF1ZW5jZUlkKHNlcXVlbmNlSW5kZXgsIHNlcXVlbmNlSWQpXSA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlcXVlbmNlc1RvQW5pbWF0ZSA9IEFycmF5LmlzQXJyYXkoc2VxdWVuY2VzKSAmJiBzZXF1ZW5jZXMubGVuZ3RoXHJcbiAgICAgICAgICAgID8gc2VxdWVuY2VzXHJcbiAgICAgICAgICAgIDogT2JqZWN0LnZhbHVlcyhhbmltYXRpb25zUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsQW5pbWF0aW9uU3RhdGUgPSB7fTtcclxuICAgICAgICAocGxheSA/IHNlcXVlbmNlc1RvQW5pbWF0ZSA6IFsuLi5zZXF1ZW5jZXNUb0FuaW1hdGVdLnJldmVyc2UoKSkucmVkdWNlKChwcmV2aW91cywgeyBzZXF1ZW5jZUlkLCBzZXF1ZW5jZUluZGV4LCBkdXJhdGlvbiA9IERFRkFVTFRfRFVSQVRJT04sIGRlbGF5LCBvdmVybGF5LCB9LCBjdXJyZW50SW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBnZXRTZXF1ZW5jZUlkKHNlcXVlbmNlSW5kZXgsIHNlcXVlbmNlSWQsIGN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb3RhbER1cmF0aW9uID0gY2FsY3VsYXRlVG90YWxEdXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGRlbGF5LFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBjdXJyZW50VG90YWxEdXJhdGlvbiArIHByZXZpb3VzO1xyXG4gICAgICAgICAgICBsb2NhbEFuaW1hdGlvblN0YXRlW2lkXSA9IHtcclxuICAgICAgICAgICAgICAgIHBsYXksXHJcbiAgICAgICAgICAgICAgICBwYXVzZTogIXBsYXksXHJcbiAgICAgICAgICAgICAgICBkZWxheTogKGRlbGF5IHx8IDApICsgcHJldmlvdXMsXHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVkOiB0cnVlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdG90YWxEdXJhdGlvbjtcclxuICAgICAgICB9LCAwKTtcclxuICAgICAgICBzZXRBbmltYXRpb25TdGF0ZXMobG9jYWxBbmltYXRpb25TdGF0ZSk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW3BsYXldKTtcclxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEFuaW1hdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGFuaW1hdGlvblN0YXRlcywgcmVnaXN0ZXIgfSB9LCBjaGlsZHJlbikpO1xyXG59XG5cbnZhciBzZWNUb01zID0gKG1zKSA9PiAobXMgfHwgMCkgKiAxMDAwO1xuXG5mdW5jdGlvbiBBbmltYXRlKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IHBsYXksIGNoaWxkcmVuLCByZW5kZXIsIHN0YXJ0LCBlbmQsIGNvbXBsZXRlID0gJycsIG9uQ29tcGxldGUsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSBERUZBVUxUX0RVUkFUSU9OLCBlYXNlVHlwZSA9IERFRkFVTFRfRUFTRV9UWVBFLCBzZXF1ZW5jZUlkLCBzZXF1ZW5jZUluZGV4LCB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBvbkNvbXBsZXRlVGltZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XHJcbiAgICBjb25zdCBbc3R5bGUsIHNldFN0eWxlXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoc3RhcnQgfHwge30pO1xyXG4gICAgY29uc3QgeyByZWdpc3RlciwgYW5pbWF0aW9uU3RhdGVzID0ge30gfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChBbmltYXRlQ29udGV4dCk7XHJcbiAgICBjb25zdCBpZCA9IGdldFNlcXVlbmNlSWQoc2VxdWVuY2VJbmRleCwgc2VxdWVuY2VJZCk7XHJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCghaXNVbmRlZmluZWQoc2VxdWVuY2VJbmRleCkgJiYgc2VxdWVuY2VJbmRleCA+PSAwKSB8fCBzZXF1ZW5jZUlkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyKHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW10pO1xyXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblN0YXRlID0gYW5pbWF0aW9uU3RhdGVzW2lkXSB8fCB7fTtcclxuICAgICAgICBzZXRTdHlsZSh7XHJcbiAgICAgICAgICAgIC4uLihwbGF5IHx8IGFuaW1hdGlvblN0YXRlLnBsYXkgPyBlbmQgOiBzdGFydCksXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGAke0FMTH0gJHtkdXJhdGlvbn1zICR7ZWFzZVR5cGV9ICR7YW5pbWF0aW9uU3RhdGUuZGVsYXkgfHwgZGVsYXl9c2AsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHBsYXkgJiYgKGNvbXBsZXRlIHx8IG9uQ29tcGxldGUpKSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVUaW1lUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlICYmIHNldFN0eWxlKGNvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9LCBzZWNUb01zKChhbmltYXRpb25TdGF0ZS5kZWxheSB8fCBkZWxheSkgKyBkdXJhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4gb25Db21wbGV0ZVRpbWVSZWYuY3VycmVudCAmJiBjbGVhclRpbWVvdXQob25Db21wbGV0ZVRpbWVSZWYuY3VycmVudCk7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgYW5pbWF0aW9uU3RhdGVzLFxyXG4gICAgICAgIHBsYXksXHJcbiAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgZWFzZVR5cGUsXHJcbiAgICAgICAgZGVsYXksXHJcbiAgICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBlbmQsXHJcbiAgICAgICAgY29tcGxldGUsXHJcbiAgICBdKTtcclxuICAgIHJldHVybiByZW5kZXIgPyByZW5kZXIoeyBzdHlsZSB9KSA6IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBzdHlsZSB9LCBjaGlsZHJlbik7XHJcbn1cblxudmFyIGNhbWVsQ2FzZVRvRGFzaCA9IChjYW1lbENhc2UpID0+IGNhbWVsQ2FzZSA/IGNhbWVsQ2FzZS5yZXBsYWNlKC9bQS1aXS9nLCBjID0+IGAtJHtjLnRvTG93ZXJDYXNlKCl9YCkgOiAnJztcblxuY29uc3QgZ2VuZXJhdGVLZXlmcmFtZXMgPSAoa2V5ZnJhbWVzKSA9PiB7XHJcbiAgICBjb25zdCBhbmltYXRpb25MZW5ndGggPSBrZXlmcmFtZXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGtleWZyYW1lcy5yZWR1Y2UoKHByZXZpb3VzLCBrZXlmcmFtZSwgY3VycmVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3Qga2V5ZnJhbWVQZXJjZW50YWdlID0gcGFyc2VGbG9hdCgoMTAwIC8gKGFuaW1hdGlvbkxlbmd0aCAtIDEpKS50b0ZpeGVkKDIpKSAqIGN1cnJlbnRJbmRleDtcclxuICAgICAgICBpZiAodHlwZW9mIGtleWZyYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7cHJldmlvdXN9ICR7a2V5ZnJhbWVQZXJjZW50YWdlfSUgeyR7a2V5ZnJhbWV9fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrZXlmcmFtZSk7XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICYmIGlzTmFOKCtrZXlzWzBdKSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZUNvbnRlbnQgPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGAke2FjY30gJHtjYW1lbENhc2VUb0Rhc2goa2V5KX06ICR7a2V5ZnJhbWVba2V5XX07YCwgJycpO1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7cHJldmlvdXN9ICR7a2V5ZnJhbWVQZXJjZW50YWdlfSUgeyR7a2V5ZnJhbWVDb250ZW50fX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYCR7cHJldmlvdXN9ICR7a2V5c1swXX0lIHske2tleWZyYW1lW2tleXNbMF1dfX1gO1xyXG4gICAgfSwgJycpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZSh7IGtleWZyYW1lcywgYW5pbWF0aW9uTmFtZSwgfSkge1xyXG4gICAgcmV0dXJuIGBAa2V5ZnJhbWVzICR7YW5pbWF0aW9uTmFtZX0geyR7Z2VuZXJhdGVLZXlmcmFtZXMoa2V5ZnJhbWVzKX19YDtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVUYWcoeyBrZXlmcmFtZXMsIGFuaW1hdGlvbk5hbWUsIH0pIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIGxldCBzdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtaWQ9cnNpXScpO1xyXG4gICAgaWYgKCFzdHlsZVRhZykge1xyXG4gICAgICAgIHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAncnNpJyk7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IChfYyA9IChfYiA9IChfYSA9IHN0eWxlVGFnLnNoZWV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3NzUnVsZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIChfZCA9IHN0eWxlVGFnLnNoZWV0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaW5zZXJ0UnVsZShjcmVhdGVTdHlsZSh7XHJcbiAgICAgICAgICAgIGtleWZyYW1lcyxcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICB9KSwgaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdyZWFjdCBzaW1wbGUgYW5pbWF0ZSwgZXJyb3IgZm91bmQgZHVyaW5nIGluc2VydCBzdHlsZSAnLCBlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlVGFnLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgfTtcclxufVxuXG52YXIgZGVsZXRlUnVsZXMgPSAoc2hlZXQsIGRlbGV0ZU5hbWUpID0+IHtcclxuICAgIGlmICghc2hlZXQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IE9iamVjdC52YWx1ZXMoc2hlZXQuY3NzUnVsZXMpLmZpbmRJbmRleCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGRlbGV0ZU5hbWUpO1xyXG4gICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcclxuICAgIH1cclxufTtcblxudmFyIGNyZWF0ZVJhbmRvbU5hbWUgPSAoKSA9PiBgUlNJLSR7TWF0aC5yYW5kb20oKVxyXG4gICAgLnRvU3RyaW5nKDM2KVxyXG4gICAgLnN1YnN0cigyLCA5KX1gO1xuXG52YXIgZ2V0UGxheVN0YXRlID0gKHBhdXNlKSA9PiAocGF1c2UgPyBQQVVTRUQgOiBSVU5OSU5HKTtcblxuZnVuY3Rpb24gQW5pbWF0ZUtleWZyYW1lcyhwcm9wcykge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgcGxheSA9IGZhbHNlLCBwYXVzZSA9IGZhbHNlLCByZW5kZXIsIGR1cmF0aW9uID0gREVGQVVMVF9EVVJBVElPTiwgZGVsYXkgPSAwLCBlYXNlVHlwZSA9IERFRkFVTFRfRUFTRV9UWVBFLCBkaXJlY3Rpb24gPSBERUZBVUxUX0RJUkVDVElPTiwgZmlsbE1vZGUgPSBERUZBVUxUX0ZJTExNT0RFLCBpdGVyYXRpb25Db3VudCA9IDEsIHNlcXVlbmNlSW5kZXgsIGtleWZyYW1lcywgc2VxdWVuY2VJZCwgfSA9IHByb3BzO1xyXG4gICAgbGV0IHBhdXNlVmFsdWU7XHJcbiAgICBjb25zdCBhbmltYXRpb25OYW1lUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe1xyXG4gICAgICAgIGZvcndhcmQ6ICcnLFxyXG4gICAgICAgIHJldmVyc2U6ICcnLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjb250cm9sbGVkID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3Qgc3R5bGVUYWdSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZih7XHJcbiAgICAgICAgZm9yd2FyZDogbnVsbCxcclxuICAgICAgICByZXZlcnNlOiBudWxsLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBpZCA9IGdldFNlcXVlbmNlSWQoc2VxdWVuY2VJbmRleCwgc2VxdWVuY2VJZCk7XHJcbiAgICBjb25zdCB7IHJlZ2lzdGVyLCBhbmltYXRpb25TdGF0ZXMgPSB7fSB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KEFuaW1hdGVDb250ZXh0KTtcclxuICAgIGNvbnN0IGFuaW1hdGVTdGF0ZSA9IGFuaW1hdGlvblN0YXRlc1tpZF0gfHwge307XHJcbiAgICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKTtcclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBzdHlsZVRhZyA9IHN0eWxlVGFnUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudDtcclxuICAgICAgICBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQuZm9yd2FyZCA9IGNyZWF0ZVJhbmRvbU5hbWUoKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gY3JlYXRlVGFnKHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZTogYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LmZvcndhcmQsXHJcbiAgICAgICAgICAgIGtleWZyYW1lcyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdHlsZVRhZ1JlZi5jdXJyZW50LmZvcndhcmQgPSByZXN1bHQuc3R5bGVUYWc7XHJcbiAgICAgICAgYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LnJldmVyc2UgPSBjcmVhdGVSYW5kb21OYW1lKCk7XHJcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVGFnKHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZTogYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LnJldmVyc2UsXHJcbiAgICAgICAgICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLnJldmVyc2UoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdHlsZVRhZ1JlZi5jdXJyZW50LnJldmVyc2UgPSByZXN1bHQuc3R5bGVUYWc7XHJcbiAgICAgICAgcmVnaXN0ZXIocHJvcHMpO1xyXG4gICAgICAgIGlmIChwbGF5KSB7XHJcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBkZWxldGVSdWxlcygoX2EgPSBzdHlsZVRhZy5mb3J3YXJkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hlZXQsIGFuaW1hdGlvbk5hbWUuZm9yd2FyZCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGVzKChfYiA9IHN0eWxlVGFnLnJldmVyc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGVldCwgYW5pbWF0aW9uTmFtZS5yZXZlcnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtdKTtcclxuICAgIGlmIChhbmltYXRlU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZC5jdXJyZW50KSB7XHJcbiAgICAgICAgcGF1c2VWYWx1ZSA9IGFuaW1hdGVTdGF0ZS5wYXVzZTtcclxuICAgICAgICBpZiAoIWFuaW1hdGVTdGF0ZS5wYXVzZSkge1xyXG4gICAgICAgICAgICBjb250cm9sbGVkLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhdXNlVmFsdWUgPSBwYXVzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0eWxlID0ge1xyXG4gICAgICAgIGFuaW1hdGlvbjogYCR7ZHVyYXRpb259cyAke2Vhc2VUeXBlfSAke2FuaW1hdGVTdGF0ZS5kZWxheSB8fCBkZWxheX1zICR7aXRlcmF0aW9uQ291bnR9ICR7ZGlyZWN0aW9ufSAke2ZpbGxNb2RlfSAke2dldFBsYXlTdGF0ZShwYXVzZVZhbHVlKX0gJHsoKGFuaW1hdGVTdGF0ZS5jb250cm9sbGVkID8gYW5pbWF0ZVN0YXRlLnBsYXkgOiBwbGF5KVxyXG4gICAgICAgICAgICA/IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5mb3J3YXJkXHJcbiAgICAgICAgICAgIDogYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LnJldmVyc2UpIHx8ICcnfWAsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJlbmRlciA/IHJlbmRlcih7IHN0eWxlIH0pIDogUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlIHx8IHt9IH0sIGNoaWxkcmVuKTtcclxufVxuXG5mdW5jdGlvbiB1c2VBbmltYXRlKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIGNvbXBsZXRlLCBvbkNvbXBsZXRlLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gREVGQVVMVF9EVVJBVElPTiwgZWFzZVR5cGUgPSBERUZBVUxUX0VBU0VfVFlQRSwgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IFJlYWN0X19uYW1lc3BhY2UudXNlTWVtbygoKSA9PiBgJHtBTEx9ICR7ZHVyYXRpb259cyAke2Vhc2VUeXBlfSAke2RlbGF5fXNgLCBbZHVyYXRpb24sIGVhc2VUeXBlLCBkZWxheV0pO1xyXG4gICAgY29uc3QgW2FuaW1hdGUsIHNldEFuaW1hdGVdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7XHJcbiAgICAgICAgaXNQbGF5aW5nOiBmYWxzZSxcclxuICAgICAgICBzdHlsZTogeyAuLi5zdGFydCwgdHJhbnNpdGlvbiB9LFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IGlzUGxheWluZywgc3R5bGUgfSA9IGFuaW1hdGU7XHJcbiAgICBjb25zdCBvbkNvbXBsZXRlVGltZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCk7XHJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKChvbkNvbXBsZXRlIHx8IGNvbXBsZXRlKSAmJiBpc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgb25Db21wbGV0ZVRpbWVSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBbmltYXRlKChhbmltYXRlKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hbmltYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogY29tcGxldGUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBzZWNUb01zKGRlbGF5ICsgZHVyYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IG9uQ29tcGxldGVUaW1lUmVmLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KG9uQ29tcGxldGVUaW1lUmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW2FuaW1hdGUsIGNvbXBsZXRlLCBkZWxheSwgZHVyYXRpb24sIGlzUGxheWluZywgb25Db21wbGV0ZV0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1BsYXlpbmcsXHJcbiAgICAgICAgc3R5bGUsXHJcbiAgICAgICAgcGxheTogUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygoaXNQbGF5aW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHNldEFuaW1hdGUoKGFuaW1hdGUpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAuLi5hbmltYXRlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi4oaXNQbGF5aW5nID8gZW5kIDogc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXNQbGF5aW5nLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSwgW2VuZCwgc3RhcnQsIHRyYW5zaXRpb25dKSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZUtleWZyYW1lcyhwcm9wcykge1xyXG4gICAgY29uc3QgeyBkdXJhdGlvbiA9IERFRkFVTFRfRFVSQVRJT04sIGRlbGF5ID0gMCwgZWFzZVR5cGUgPSBERUZBVUxUX0VBU0VfVFlQRSwgZGlyZWN0aW9uID0gREVGQVVMVF9ESVJFQ1RJT04sIGZpbGxNb2RlID0gREVGQVVMVF9GSUxMTU9ERSwgaXRlcmF0aW9uQ291bnQgPSAxLCBrZXlmcmFtZXMsIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGFuaW1hdGlvbk5hbWVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZih7XHJcbiAgICAgICAgZm9yd2FyZDogJycsXHJcbiAgICAgICAgcmV2ZXJzZTogJycsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHN0eWxlVGFnUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe1xyXG4gICAgICAgIGZvcndhcmQ6IG51bGwsXHJcbiAgICAgICAgcmV2ZXJzZTogbnVsbCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgeyByZWdpc3RlciB9ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KEFuaW1hdGVDb250ZXh0KTtcclxuICAgIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKG51bGwpO1xyXG4gICAgY29uc3QgW2lzUGF1c2VkLCBzZXRJc1BhdXNlZF0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKTtcclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBzdHlsZVRhZyA9IHN0eWxlVGFnUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudDtcclxuICAgICAgICBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQuZm9yd2FyZCA9IGNyZWF0ZVJhbmRvbU5hbWUoKTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gY3JlYXRlVGFnKHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZTogYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LmZvcndhcmQsXHJcbiAgICAgICAgICAgIGtleWZyYW1lcyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdHlsZVRhZ1JlZi5jdXJyZW50LmZvcndhcmQgPSByZXN1bHQuc3R5bGVUYWc7XHJcbiAgICAgICAgYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LnJldmVyc2UgPSBjcmVhdGVSYW5kb21OYW1lKCk7XHJcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVGFnKHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZTogYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LnJldmVyc2UsXHJcbiAgICAgICAgICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLnJldmVyc2UoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdHlsZVRhZ1JlZi5jdXJyZW50LnJldmVyc2UgPSByZXN1bHQuc3R5bGVUYWc7XHJcbiAgICAgICAgcmVnaXN0ZXIocHJvcHMpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGVzKChfYSA9IHN0eWxlVGFnLmZvcndhcmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaGVldCwgYW5pbWF0aW9uTmFtZS5mb3J3YXJkKTtcclxuICAgICAgICAgICAgZGVsZXRlUnVsZXMoKF9iID0gc3R5bGVUYWcucmV2ZXJzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoZWV0LCBhbmltYXRpb25OYW1lLnJldmVyc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3Qgc3R5bGUgPSB7XHJcbiAgICAgICAgYW5pbWF0aW9uOiBgJHtkdXJhdGlvbn1zICR7ZWFzZVR5cGV9ICR7ZGVsYXl9cyAke2l0ZXJhdGlvbkNvdW50fSAke2RpcmVjdGlvbn0gJHtmaWxsTW9kZX0gJHtnZXRQbGF5U3RhdGUoaXNQYXVzZWQpfSAke2lzUGxheWluZyA9PT0gbnVsbFxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogaXNQbGF5aW5nXHJcbiAgICAgICAgICAgICAgICA/IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5mb3J3YXJkXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5yZXZlcnNlfWAsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdHlsZSxcclxuICAgICAgICBwbGF5OiBzZXRJc1BsYXlpbmcsXHJcbiAgICAgICAgcGF1c2U6IHNldElzUGF1c2VkLFxyXG4gICAgICAgIGlzUGxheWluZzogISFpc1BsYXlpbmcsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5V2l0aE51bWJlcnMobGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiBudWxsKTtcclxufVxuXG5mdW5jdGlvbiB1c2VBbmltYXRlR3JvdXAocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgc2VxdWVuY2VzID0gW10gfSA9IHByb3BzO1xyXG4gICAgY29uc3QgZGVmYXVsdEFycmF5ID0gY3JlYXRlQXJyYXlXaXRoTnVtYmVycyhzZXF1ZW5jZXMubGVuZ3RoKS5tYXAoKF8sIGluZGV4KSA9PiBwcm9wcy5zZXF1ZW5jZXNbaW5kZXhdLnN0YXJ0KTtcclxuICAgIGNvbnN0IFtzdHlsZXMsIHNldFN0eWxlc10gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGRlZmF1bHRBcnJheSk7XHJcbiAgICBjb25zdCBbaXNQbGF5aW5nLCBzZXRQbGF5aW5nXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uTmFtZXNSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihbXSk7XHJcbiAgICBjb25zdCBzdHlsZVRhZ1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKFtdKTtcclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXF1ZW5jZXMuZm9yRWFjaCgoeyBrZXlmcmFtZXMgfSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5ZnJhbWVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9uTmFtZXNSZWYuY3VycmVudFtpXSkge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uTmFtZXNSZWYuY3VycmVudFtpXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgc3R5bGVUYWdSZWYuY3VycmVudFtpXSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnRbaV0uZm9yd2FyZCA9IGNyZWF0ZVJhbmRvbU5hbWUoKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGNyZWF0ZVRhZyh7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25OYW1lOiBhbmltYXRpb25OYW1lc1JlZi5jdXJyZW50W2ldLmZvcndhcmQsXHJcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdHlsZVRhZ1JlZi5jdXJyZW50W2ldLmZvcndhcmQgPSByZXN1bHQuc3R5bGVUYWc7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnRbaV0ucmV2ZXJzZSA9IGNyZWF0ZVJhbmRvbU5hbWUoKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlVGFnKHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnRbaV0ucmV2ZXJzZSxcclxuICAgICAgICAgICAgICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLnJldmVyc2UoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN0eWxlVGFnUmVmLmN1cnJlbnRbaV0ucmV2ZXJzZSA9IHJlc3VsdC5zdHlsZVRhZztcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBzdHlsZVRhZ3MgPSBzdHlsZVRhZ1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWVzID0gYW5pbWF0aW9uTmFtZXNSZWYuY3VycmVudDtcclxuICAgICAgICByZXR1cm4gKCkgPT4gT2JqZWN0LnZhbHVlcyhhbmltYXRpb25OYW1lcykuZm9yRWFjaCgoeyBmb3J3YXJkLCByZXZlcnNlIH0sIGkpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgZGVsZXRlUnVsZXMoKF9hID0gc3R5bGVUYWdzW2ldLmZvcndhcmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaGVldCwgZm9yd2FyZCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGVzKChfYiA9IHN0eWxlVGFnc1tpXS5yZXZlcnNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hlZXQsIHJldmVyc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHBsYXkgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNhbGxiYWNrKChpc1BsYXkpID0+IHtcclxuICAgICAgICBsZXQgdG90YWxEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uUmVmV2l0aE9yZGVyID0gaXNQbGF5XHJcbiAgICAgICAgICAgID8gYW5pbWF0aW9uTmFtZXNSZWYuY3VycmVudFxyXG4gICAgICAgICAgICA6IFsuLi5hbmltYXRpb25OYW1lc1JlZi5jdXJyZW50XS5yZXZlcnNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gKGlzUGxheSA/IHNlcXVlbmNlcyA6IFsuLi5zZXF1ZW5jZXNdLnJldmVyc2UoKSkubWFwKChjdXJyZW50LCBjdXJyZW50SW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBkdXJhdGlvbiA9IERFRkFVTFRfRFVSQVRJT04sIGRlbGF5ID0gMCwgb3ZlcmxheSwga2V5ZnJhbWVzLCBpdGVyYXRpb25Db3VudCA9IDEsIGVhc2VUeXBlID0gREVGQVVMVF9FQVNFX1RZUEUsIGRpcmVjdGlvbiA9IERFRkFVTFRfRElSRUNUSU9OLCBmaWxsTW9kZSA9IERFRkFVTFRfRklMTE1PREUsIGVuZCA9IHt9LCBzdGFydCA9IHt9LCB9ID0gY3VycmVudDtcclxuICAgICAgICAgICAgY29uc3QgZGVsYXlEdXJhdGlvbiA9IGN1cnJlbnRJbmRleCA9PT0gMCA/IGRlbGF5IDogdG90YWxEdXJhdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IGAke0FMTH0gJHtkdXJhdGlvbn1zICR7ZWFzZVR5cGV9ICR7ZGVsYXlEdXJhdGlvbn1zYDtcclxuICAgICAgICAgICAgdG90YWxEdXJhdGlvbiA9XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVUb3RhbER1cmF0aW9uKHsgZHVyYXRpb24sIGRlbGF5LCBvdmVybGF5IH0pICsgdG90YWxEdXJhdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIGtleWZyYW1lc1xyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBgJHtkdXJhdGlvbn1zICR7ZWFzZVR5cGV9ICR7ZGVsYXlEdXJhdGlvbn1zICR7aXRlcmF0aW9uQ291bnR9ICR7ZGlyZWN0aW9ufSAke2ZpbGxNb2RlfSAke1JVTk5JTkd9ICR7aXNQbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYW5pbWF0aW9uUmVmV2l0aE9yZGVyW2N1cnJlbnRJbmRleF0uZm9yd2FyZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFuaW1hdGlvblJlZldpdGhPcmRlcltjdXJyZW50SW5kZXhdLnJldmVyc2V9YCxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLihpc1BsYXkgPyBlbmQgOiBzdGFydCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2V0U3R5bGVzKGlzUGxheSA/IHN0eWxlcyA6IFsuLi5zdHlsZXNdLnJldmVyc2UoKSk7XHJcbiAgICAgICAgc2V0UGxheWluZyhpc1BsYXkpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIHsgc3R5bGVzLCBwbGF5LCBpc1BsYXlpbmcgfTtcclxufVxuXG5leHBvcnRzLkFuaW1hdGUgPSBBbmltYXRlO1xuZXhwb3J0cy5BbmltYXRlR3JvdXAgPSBBbmltYXRlR3JvdXA7XG5leHBvcnRzLkFuaW1hdGVLZXlmcmFtZXMgPSBBbmltYXRlS2V5ZnJhbWVzO1xuZXhwb3J0cy51c2VBbmltYXRlID0gdXNlQW5pbWF0ZTtcbmV4cG9ydHMudXNlQW5pbWF0ZUdyb3VwID0gdXNlQW5pbWF0ZUdyb3VwO1xuZXhwb3J0cy51c2VBbmltYXRlS2V5ZnJhbWVzID0gdXNlQW5pbWF0ZUtleWZyYW1lcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-simple-animate/dist/index.js\n");

/***/ })

};
;